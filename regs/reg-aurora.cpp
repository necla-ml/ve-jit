
#include "reg-aurora.hpp"

static_assert( !valid(invalidReg()), "invalidReg() tests as valid()!");

namespace detail {
    /** register i string begins at offset 6*i.   generated by \c prt_regnames.cpp */
    char const* aurora_regnames =
        "%s0\0\0\0"  "%s1\0\0\0"  "%s2\0\0\0"  "%s3\0\0\0"  "%s4\0\0\0"
        "%s5\0\0\0"  "%s6\0\0\0"  "%s7\0\0\0"  "%sl\0\0\0"  "%fp\0\0\0"
        "%lr\0\0\0"  "%sp\0\0\0"  "%s12\0\0"  "%s13\0\0"  "%tp\0\0\0"
        "%got\0\0"  "%plt\0\0"  "%s17\0\0"  "%s18\0\0"  "%s19\0\0"
        "%s20\0\0"  "%s21\0\0"  "%s22\0\0"  "%s23\0\0"  "%s24\0\0"
        "%s25\0\0"  "%s26\0\0"  "%s27\0\0"  "%s28\0\0"  "%s29\0\0"
        "%s30\0\0"  "%s31\0\0"  "%s32\0\0"  "%s33\0\0"  "%s34\0\0"
        "%s35\0\0"  "%s36\0\0"  "%s37\0\0"  "%s38\0\0"  "%s39\0\0"
        "%s40\0\0"  "%s41\0\0"  "%s42\0\0"  "%s43\0\0"  "%s44\0\0"
        "%s45\0\0"  "%s46\0\0"  "%s47\0\0"  "%s48\0\0"  "%s49\0\0"
        "%s50\0\0"  "%s51\0\0"  "%s52\0\0"  "%s53\0\0"  "%s54\0\0"
        "%s55\0\0"  "%s56\0\0"  "%s57\0\0"  "%s58\0\0"  "%s59\0\0"
        "%s60\0\0"  "%s61\0\0"  "%s62\0\0"  "%s63\0\0"

        "%v0\0\0\0"  "%v1\0\0\0"  "%v2\0\0\0"  "%v3\0\0\0"  "%v4\0\0\0"
        "%v5\0\0\0"  "%v6\0\0\0"  "%v7\0\0\0"  "%v8\0\0\0"  "%v9\0\0\0"
        "%v10\0\0"  "%v11\0\0"  "%v12\0\0"  "%v13\0\0"  "%v14\0\0"
        "%v15\0\0"  "%v16\0\0"  "%v17\0\0"  "%v18\0\0"  "%v19\0\0"
        "%v20\0\0"  "%v21\0\0"  "%v22\0\0"  "%v23\0\0"  "%v24\0\0"
        "%v25\0\0"  "%v26\0\0"  "%v27\0\0"  "%v28\0\0"  "%v29\0\0"
        "%v30\0\0"  "%v31\0\0"  "%v32\0\0"  "%v33\0\0"  "%v34\0\0"
        "%v35\0\0"  "%v36\0\0"  "%v37\0\0"  "%v38\0\0"  "%v39\0\0"
        "%v40\0\0"  "%v41\0\0"  "%v42\0\0"  "%v43\0\0"  "%v44\0\0"
        "%v45\0\0"  "%v46\0\0"  "%v47\0\0"  "%v48\0\0"  "%v49\0\0"
        "%v50\0\0"  "%v51\0\0"  "%v52\0\0"  "%v53\0\0"  "%v54\0\0"
        "%v55\0\0"  "%v56\0\0"  "%v57\0\0"  "%v58\0\0"  "%v59\0\0"
        "%v60\0\0"  "%v61\0\0"  "%v62\0\0"  "%v63\0\0"

        "%vm0\0\0"  "%vm1\0\0"  "%vm2\0\0"  "%vm3\0\0"  "%vm4\0\0"
        "%vm5\0\0"  "%vm6\0\0"  "%vm7\0\0"  "%vm8\0\0"  "%vm9\0\0"
        "%vm10\0"  "%vm11\0"  "%vm12\0"  "%vm13\0"  "%vm14\0"
        "%vm15\0"
        ;
}//detail::

#if 0
char const* asmname(RegId const r){
    assert(valid(r));
    return &aurora_regnames[6*r];
}
#endif

#define RB RegisterBase
// classes
#define FLG RB::Flags
#define USE RB::Use
#define CLS RB::Cls
#define SUB RB::Sub
#define VLN RB::Vlen
#define MSC RB::Misc
// functions
#define INT RB::Int
// values, as plain integers
#define uF INT(USE::free)
#define cS INT(CLS::scalar)
#define cV INT(CLS::vector)
#define cM INT(CLS::mask)

#define BF(RB_ENUM) RB::shift(RB_ENUM)   /* this one accepts arbitrary enums */

#define U(USE_ENUM) RB::shift(RB::Use::USE_ENUM) /* RegBase definitions are ok, no aurora specifics */

// These are Aurora specific so we need to cast the Aurora enum value to RegBase enum type...
#define MISC(INT) RB::shift(RB::Enum<RB::Misc>(INT))

/** Aurora default chip register state.
 *
 * todo: use defRegFlags throughout, then switch to auto-generate the initializer-list
 *       (varags constexpr trickery)
 *
 * Note: Aurora const MISC(reserve) should always imply dynamic USE(reserved), instead
 *       of the default 'free'.   MISC('preserve') is a const bit that tells you that
 *       prologue and epilogue may need to push/pop this register to conform to C ABI.
 *
 * Note: We can actually use the some of the C preserved registers as temporaries
 *       in the assembler API for internal ops.
 *       Ex. msk.cpp assembler does not adhere to C ABI, so it uses s12,s13
 *           rather regularly as temporaries, because they can be clobbered
 *           without ill effect on the C ABI (and they don't need to be preserved
 *           across the call to the asm function).   But you still need to tell
 *           compiler that those regs are clobbered.  (It also chose s18 and s19
 *           as tmp regs). I did use clobber %lr for temporaries, because the
 *           assembler code needs it to return (may as well keep it in %s10).
 */
ChipRegistersAurora::ChipRegistersAurora()
    : regs{
        /* default (0) is Use=free, Cls=none(illegal), Sub=def, Vlen=def, Misc=def */
           RegisterBase{RegId( 0), BF(CLS::scalar)},
           RegisterBase{RegId( 1), BF(CLS::scalar)},
           RegisterBase{RegId( 2), BF(CLS::scalar)},
           RegisterBase{RegId( 3), BF(CLS::scalar)},
           RegisterBase{RegId( 4), BF(CLS::scalar)},
           RegisterBase{RegId( 5), BF(CLS::scalar)},
           RegisterBase{RegId( 6), BF(CLS::scalar)},
           RegisterBase{RegId( 7), BF(CLS::scalar)},
           RegisterBase{RegId( 8), BF(CLS::scalar) | MISC(reserve|preserve) | U(reserved)},	// %s8  %sl stack limit
           RegisterBase{RegId( 9),  BF(CLS::scalar) | MISC(reserve|preserve) | U(reserved)},    // %s9  %fp frame pointer
           //RegisterBase{RegId( 9), defRegFlags(RegId(9))},					// %s9  %fp frame pointer
	   // oops defRegFlags is a bit wrong still...
           RegisterBase{RegId( 10), BF(CLS::scalar) | MISC(reserve) | U(reserved)},		// %s10 %lr return address
           RegisterBase{RegId( 11), BF(CLS::scalar) | MISC(reserve|preserve) | U(reserved)},	// %s11 %sp stack pointer
           RegisterBase{RegId( 12), BF(CLS::scalar) | MISC(reserve) | U(reserved)},		// %s12     outer, addr of called fn
           RegisterBase{RegId( 13), BF(CLS::scalar) | MISC(reserve) | U(reserved)},		// %s13     fn id for dynamic linker
           RegisterBase{RegId( 14), BF(CLS::scalar) | MISC(reserve|preserve) | U(reserved)},	// %s14 %tp thread ptr
           RegisterBase{RegId( 15), BF(CLS::scalar) | MISC(reserve|preserve) | U(reserved)},	// %s15 %got Global Offset Table
           RegisterBase{RegId( 16), BF(CLS::scalar) | MISC(reserve|preserve) | U(reserved)},	// %s16 %plt Procedure Linkage Reg
           RegisterBase{RegId( 17), BF(CLS::scalar) | MISC(reserve|preserve) | U(reserved)},	// %s17      Link-area register
           RegisterBase{RegId( 18), BF(CLS::scalar) | MISC(preserve)},
           RegisterBase{RegId( 19), BF(CLS::scalar) | MISC(preserve)},
           RegisterBase{RegId( 20), BF(CLS::scalar) | MISC(preserve)},
           RegisterBase{RegId( 21), BF(CLS::scalar) | MISC(preserve)},
           RegisterBase{RegId( 22), BF(CLS::scalar) | MISC(preserve)},
           RegisterBase{RegId( 23), BF(CLS::scalar) | MISC(preserve)},
           RegisterBase{RegId( 24), BF(CLS::scalar) | MISC(preserve)},
           RegisterBase{RegId( 25), BF(CLS::scalar) | MISC(preserve)},
           RegisterBase{RegId( 26), BF(CLS::scalar) | MISC(preserve)},
           RegisterBase{RegId( 27), BF(CLS::scalar) | MISC(preserve)},
           RegisterBase{RegId( 28), BF(CLS::scalar) | MISC(preserve)},
           RegisterBase{RegId( 29), BF(CLS::scalar) | MISC(preserve)},
           RegisterBase{RegId( 30), BF(CLS::scalar) | MISC(preserve)},
           RegisterBase{RegId( 31), BF(CLS::scalar) | MISC(preserve)},
           RegisterBase{RegId( 32), BF(CLS::scalar) | MISC(preserve)},
           RegisterBase{RegId( 33), BF(CLS::scalar) | MISC(preserve)},
           RegisterBase{RegId( 34), BF(CLS::scalar)},
           RegisterBase{RegId( 35), BF(CLS::scalar)},
           RegisterBase{RegId( 36), BF(CLS::scalar)},
           RegisterBase{RegId( 37), BF(CLS::scalar)},
           RegisterBase{RegId( 38), BF(CLS::scalar)},
           RegisterBase{RegId( 39), BF(CLS::scalar)},
           RegisterBase{RegId( 40), BF(CLS::scalar)},
           RegisterBase{RegId( 41), BF(CLS::scalar)},
           RegisterBase{RegId( 42), BF(CLS::scalar)},
           RegisterBase{RegId( 43), BF(CLS::scalar)},
           RegisterBase{RegId( 44), BF(CLS::scalar)},
           RegisterBase{RegId( 45), BF(CLS::scalar)},
           RegisterBase{RegId( 46), BF(CLS::scalar)},
           RegisterBase{RegId( 47), BF(CLS::scalar)},
           RegisterBase{RegId( 48), BF(CLS::scalar)},
           RegisterBase{RegId( 49), BF(CLS::scalar)},
           RegisterBase{RegId( 50), BF(CLS::scalar)},
           RegisterBase{RegId( 51), BF(CLS::scalar)},
           RegisterBase{RegId( 52), BF(CLS::scalar)},
           RegisterBase{RegId( 53), BF(CLS::scalar)},
           RegisterBase{RegId( 54), BF(CLS::scalar)},
           RegisterBase{RegId( 55), BF(CLS::scalar)},
           RegisterBase{RegId( 56), BF(CLS::scalar)},
           RegisterBase{RegId( 57), BF(CLS::scalar)},
           RegisterBase{RegId( 58), BF(CLS::scalar)},
           RegisterBase{RegId( 59), BF(CLS::scalar)},
           RegisterBase{RegId( 60), BF(CLS::scalar)},
           RegisterBase{RegId( 61), BF(CLS::scalar)},
           RegisterBase{RegId( 62), BF(CLS::scalar)},
           RegisterBase{RegId( 63), BF(CLS::scalar)},
           RegisterBase{RegId(64+ 0), BF(CLS::vector)},
           RegisterBase{RegId(64+ 1), BF(CLS::vector)},
           RegisterBase{RegId(64+ 2), BF(CLS::vector)},
           RegisterBase{RegId(64+ 3), BF(CLS::vector)},
           RegisterBase{RegId(64+ 4), BF(CLS::vector)},
           RegisterBase{RegId(64+ 5), BF(CLS::vector)},
           RegisterBase{RegId(64+ 6), BF(CLS::vector)},
           RegisterBase{RegId(64+ 7), BF(CLS::vector)},
           RegisterBase{RegId(64+ 8), BF(CLS::vector)},
           RegisterBase{RegId(64+ 9), BF(CLS::vector)},
           RegisterBase{RegId(64+ 10), BF(CLS::vector)},
           RegisterBase{RegId(64+ 11), BF(CLS::vector)},
           RegisterBase{RegId(64+ 12), BF(CLS::vector)},
           RegisterBase{RegId(64+ 13), BF(CLS::vector)},
           RegisterBase{RegId(64+ 14), BF(CLS::vector)},
           RegisterBase{RegId(64+ 15), BF(CLS::vector)},
           RegisterBase{RegId(64+ 16), BF(CLS::vector)},
           RegisterBase{RegId(64+ 17), BF(CLS::vector)},
           RegisterBase{RegId(64+ 18), BF(CLS::vector)},
           RegisterBase{RegId(64+ 19), BF(CLS::vector)},
           RegisterBase{RegId(64+ 20), BF(CLS::vector)},
           RegisterBase{RegId(64+ 21), BF(CLS::vector)},
           RegisterBase{RegId(64+ 22), BF(CLS::vector)},
           RegisterBase{RegId(64+ 23), BF(CLS::vector)},
           RegisterBase{RegId(64+ 24), BF(CLS::vector)},
           RegisterBase{RegId(64+ 25), BF(CLS::vector)},
           RegisterBase{RegId(64+ 26), BF(CLS::vector)},
           RegisterBase{RegId(64+ 27), BF(CLS::vector)},
           RegisterBase{RegId(64+ 28), BF(CLS::vector)},
           RegisterBase{RegId(64+ 29), BF(CLS::vector)},
           RegisterBase{RegId(64+ 30), BF(CLS::vector)},
           RegisterBase{RegId(64+ 31), BF(CLS::vector)},
           RegisterBase{RegId(64+ 32), BF(CLS::vector)},
           RegisterBase{RegId(64+ 33), BF(CLS::vector)},
           RegisterBase{RegId(64+ 34), BF(CLS::vector)},
           RegisterBase{RegId(64+ 35), BF(CLS::vector)},
           RegisterBase{RegId(64+ 36), BF(CLS::vector)},
           RegisterBase{RegId(64+ 37), BF(CLS::vector)},
           RegisterBase{RegId(64+ 38), BF(CLS::vector)},
           RegisterBase{RegId(64+ 39), BF(CLS::vector)},
           RegisterBase{RegId(64+ 40), BF(CLS::vector)},
           RegisterBase{RegId(64+ 41), BF(CLS::vector)},
           RegisterBase{RegId(64+ 42), BF(CLS::vector)},
           RegisterBase{RegId(64+ 43), BF(CLS::vector)},
           RegisterBase{RegId(64+ 44), BF(CLS::vector)},
           RegisterBase{RegId(64+ 45), BF(CLS::vector)},
           RegisterBase{RegId(64+ 46), BF(CLS::vector)},
           RegisterBase{RegId(64+ 47), BF(CLS::vector)},
           RegisterBase{RegId(64+ 48), BF(CLS::vector)},
           RegisterBase{RegId(64+ 49), BF(CLS::vector)},
           RegisterBase{RegId(64+ 50), BF(CLS::vector)},
           RegisterBase{RegId(64+ 51), BF(CLS::vector)},
           RegisterBase{RegId(64+ 52), BF(CLS::vector)},
           RegisterBase{RegId(64+ 53), BF(CLS::vector)},
           RegisterBase{RegId(64+ 54), BF(CLS::vector)},
           RegisterBase{RegId(64+ 55), BF(CLS::vector)},
           RegisterBase{RegId(64+ 56), BF(CLS::vector)},
           RegisterBase{RegId(64+ 57), BF(CLS::vector)},
           RegisterBase{RegId(64+ 58), BF(CLS::vector)},
           RegisterBase{RegId(64+ 59), BF(CLS::vector)},
           RegisterBase{RegId(64+ 60), BF(CLS::vector)},
           RegisterBase{RegId(64+ 61), BF(CLS::vector)},
           RegisterBase{RegId(64+ 62), BF(CLS::vector)},
           RegisterBase{RegId(64+ 63), BF(CLS::vector)},
           RegisterBase{RegId(64+64+ 0), BF(CLS::mask)},
           RegisterBase{RegId(64+64+ 1), BF(CLS::mask)},
           RegisterBase{RegId(64+64+ 2), BF(CLS::mask)},
           RegisterBase{RegId(64+64+ 3), BF(CLS::mask)},
           RegisterBase{RegId(64+64+ 4), BF(CLS::mask)},
           RegisterBase{RegId(64+64+ 5), BF(CLS::mask)},
           RegisterBase{RegId(64+64+ 6), BF(CLS::mask)},
           RegisterBase{RegId(64+64+ 7), BF(CLS::mask)},
           RegisterBase{RegId(64+64+ 8), BF(CLS::mask)},
           RegisterBase{RegId(64+64+ 9), BF(CLS::mask)},
           RegisterBase{RegId(64+64+ 10), BF(CLS::mask)},
           RegisterBase{RegId(64+64+ 11), BF(CLS::mask)},
           RegisterBase{RegId(64+64+ 12), BF(CLS::mask)},
           RegisterBase{RegId(64+64+ 13), BF(CLS::mask)},
           RegisterBase{RegId(64+64+ 14), BF(CLS::mask)},
           RegisterBase{RegId(64+64+ 15), BF(CLS::mask)},
           }
    // could not convert ‘<brace-enclosed initializer list>()’ from ... to RegisterBase
{
}


